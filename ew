local DiscordLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt"))()

-- UI Setup
local win = DiscordLib:Window("Macro Recorder")
local main = win:Server("Main", "")
local recordTab = main:Channel("Recorder")

-- Variables
local Recording = {}
local IsRecording = false
local StartTime = 0
local RecordingFileName = "macro_recording.json"

-- Utility Functions
local function startRecording()
    IsRecording = true
    StartTime = os.clock()
    Recording = {}
    DiscordLib:Notification("Notification", "Recording Started!", "Okay!")
end

local function stopRecording()
    IsRecording = false
    DiscordLib:Notification("Notification", "Recording Stopped!", "Okay!")
end

local function saveRecording(filename)
    if syn and syn.writefile then
        local json = game:GetService("HttpService"):JSONEncode(Recording)
        syn.writefile(filename, json)
        DiscordLib:Notification("Notification", "Recording Saved as " .. filename, "Okay!")
    else
        DiscordLib:Notification("Error", "Failed to save recording! Missing executor functionality.", "Okay!")
    end
end

local function loadRecording(filename)
    if syn and syn.readfile then
        local json = syn.readfile(filename)
        Recording = game:GetService("HttpService"):JSONDecode(json)
        DiscordLib:Notification("Notification", "Recording Loaded: " .. filename, "Okay!")
    else
        DiscordLib:Notification("Error", "Failed to load recording! Missing executor functionality.", "Okay!")
    end
end

local function replayRecording()
    for _, entry in ipairs(Recording) do
        task.wait(entry.TimeFired)
        local remote = game:GetService("Workspace"):FindFirstChild(entry.Remote) -- Adjust search as needed
        if remote and remote[entry.Method] then
            remote[entry.Method](remote, unpack(entry.Arguments))
        end
    end
    DiscordLib:Notification("Notification", "Replay Completed!", "Okay!")
end

-- Metatable Hook for Recording Remotes
local function hookRemotes()
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)

    mt.__namecall = function(self, ...)
        local method = getnamecallmethod()
        local args = {...}

        if IsRecording and (method == "FireServer" or method == "InvokeServer") then
            table.insert(Recording, {
                Remote = tostring(self),
                Method = method,
                Arguments = args,
                TimeFired = os.clock() - StartTime,
            })
        end

        return oldNamecall(self, ...)
    end
    setreadonly(mt, true)
end

-- UI Buttons
recordTab:Button("Start Recording", function()
    startRecording()
end)

recordTab:Button("Stop Recording", function()
    stopRecording()
end)

recordTab:Textbox("Filename", "Enter filename here...", false, function(input)
    RecordingFileName = input
end)

recordTab:Button("Save Recording", function()
    saveRecording(RecordingFileName)
end)

recordTab:Button("Load Recording", function()
    loadRecording(RecordingFileName)
end)

recordTab:Button("Replay Recording", function()
    replayRecording()
end)

-- Hook the remotes when the script runs
hookRemotes()
DiscordLib:Notification("Notification", "Macro Recorder Ready!", "Okay!")
